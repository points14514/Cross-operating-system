; 文件名: mbr.asm
; 描述: 主引导记录 (Master Boot Record)
; 功能: 系统启动入口，负责加载第二阶段的引导加载器(loader)，并为其准备好基础环境
; 编译后必须恰好为512字节，并以0xAA55结束

;==========================================================
; 1. 初始设置与宏定义
;==========================================================
section mbr vstart=0x7c00        ; 告知编译器程序将被加载到物理地址0x7c00处[1,3,5](@ref)

; 定义Loader相关的常量（这些值需与你的整体设计匹配）
LOADER_BASE_ADDR    equ 0x9000   ; 第二阶段Loader将被加载到的内存基地址[1,6](@ref)
LOADER_START_SECTOR equ 0x2      ; Loader在硬盘上的起始扇区号(LBA模式)[1,6](@ref)

;==========================================================
; 2. 初始化段寄存器与堆栈
;==========================================================
_start:
    mov ax, cs
    mov ds, ax
    mov es, ax
    mov ss, ax
    mov sp, 0x7c00                ; 堆栈指针指向MBR起始位置下方[1,4](@ref)

;==========================================================
; 3. 清屏并显示启动信息 (可选，但强烈建议用于调试)
;==========================================================
    ; 调用BIOS中断0x10的0x06功能卷动窗口，实现清屏
    mov ax, 0x0600                ; AH=0x06(功能号), AL=0x00(清空整个窗口)
    mov bx, 0x0700                ; BH=0x07(属性:黑底白字)
    mov cx, 0                     ; CH,CL=左上角行列(0,0)
    mov dx, 0x184f                ; DH,DL=右下角行列(24,79)
    int 0x10

    ; 设置显存段寄存器，准备直接写入字符
    mov ax, 0xb800
    mov gs, ax

    ; 在屏幕特定位置显示标识符，例如"MBR"
    mov byte [gs:0x00], 'M'
    mov byte [gs:0x01], 0x0A      ; 属性字节(例如0x0A为黑底亮绿色)
    mov byte [gs:0x02], 'B'
    mov byte [gs:0x03], 0x0A
    mov byte [gs:0x04], 'R'
    mov byte [gs:0x05], 0x0A

;==========================================================
; 4. 核心任务：从硬盘加载Loader
;==========================================================
    mov eax, LOADER_START_SECTOR  ; 设置要读取的起始扇区号(LBA)[1,5](@ref)
    mov bx, LOADER_BASE_ADDR      ; 设置数据加载到的内存地址[1,6](@ref)
    mov cx, 4                     ; 设置要读取的扇区数量(根据你的Loader大小调整)
    call read_disk                ; 调用磁盘读取例程

;==========================================================
; 5. 跳转到Loader
;==========================================================
    jmp LOADER_BASE_ADDR          ; 跳转到Loader的入口点，将控制权移交[1,6](@ref)

;==========================================================
; 6. 子程序：read_disk - 从硬盘读取扇区 (使用LBA28模式)
;==========================================================
read_disk:
    ; 输入参数: EAX=LBA扇区号, BX=目标内存地址, CX=读取扇区数
    mov esi, eax                  ; 备份LBA扇区号
    mov di, cx                    ; 备份要读取的扇区数

    ; 步骤1: 设置要读取的扇区数量
    mov dx, 0x1f2
    mov al, cl
    out dx, al

    ; 步骤2: 设置LBA地址 (28位地址分布到4个端口)
    mov eax, esi
    mov dx, 0x1f3
    out dx, al                    ; LBA 0-7位

    mov dx, 0x1f4
    shr eax, 8
    out dx, al                    ; LBA 8-15位

    mov dx, 0x1f5
    shr eax, 8
    out dx, al                    ; LBA 16-23位

    mov dx, 0x1f6
    shr eax, 8
    and al, 0x0f                  ; 取LBA 24-27位
    or al, 0xe0                   ; 设置模式为LBA,主盘
    out dx, al

    ; 步骤3: 发送读命令(0x20)到命令端口
    mov dx, 0x1f7
    mov al, 0x20
    out dx, al

    ; 步骤4: 等待硬盘准备就绪
.not_ready:
    in al, dx
    and al, 0x88                  ; 检查第7位(BSY忙)和第4位(DRQ就绪)
    cmp al, 0x08                  ; 判断是否不忙且数据已准备好
    jnz .not_ready

    ; 步骤5: 从数据端口(0x1f0)读取数据到内存
    mov ax, di
    mov dx, 256                   ; 每个扇区256字(512字节)
    mul dx                        ; AX = 要读取的总字数 (扇区数 * 256)
    mov cx, ax
    mov dx, 0x1f0

.go_on_read:
    in ax, dx                     ; 从硬盘数据端口读取一个字(2字节)
    mov [bx], ax                  ; 将数据存储到目标内存地址
    add bx, 2                     ; 内存地址指针后移2字节
    loop .go_on_read              ; 循环直到读完所有数据

    ret

;==========================================================
; 7. 填充剩余空间并设置引导扇区结束标志
;==========================================================
    times 510 - ($ - $$) db 0     ; 填充剩余空间，确保总大小为510字节
    dw 0xaa55                     ; 第511-512字节的引导扇区结束标志[1,3,5](@ref)
